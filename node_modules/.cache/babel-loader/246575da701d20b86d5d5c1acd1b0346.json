{"ast":null,"code":"function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nimport { Tracer as otTracer } from 'opentracing/lib/tracer';\nimport { REFERENCE_CHILD_OF, FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, FORMAT_BINARY } from 'opentracing/lib/constants';\nimport { Span as NoopSpan } from 'opentracing/lib/span';\nimport { getTimeOrigin, find } from '../common/utils';\nimport { __DEV__ } from '../state';\nimport Span from './span';\n\nvar Tracer = function (_otTracer) {\n  _inheritsLoose(Tracer, _otTracer);\n\n  function Tracer(performanceMonitoring, transactionService, loggingService, errorLogging) {\n    var _this;\n\n    _this = _otTracer.call(this) || this;\n    _this.performanceMonitoring = performanceMonitoring;\n    _this.transactionService = transactionService;\n    _this.loggingService = loggingService;\n    _this.errorLogging = errorLogging;\n    return _this;\n  }\n\n  var _proto = Tracer.prototype;\n\n  _proto._startSpan = function _startSpan(name, options) {\n    var spanOptions = {\n      managed: true\n    };\n\n    if (options) {\n      spanOptions.timestamp = options.startTime;\n\n      if (options.childOf) {\n        spanOptions.parentId = options.childOf.id;\n      } else if (options.references && options.references.length > 0) {\n        if (options.references.length > 1) {\n          if (__DEV__) {\n            this.loggingService.debug('Elastic APM OpenTracing: Unsupported number of references, only the first childOf reference will be recorded.');\n          }\n        }\n\n        var childRef = find(options.references, function (ref) {\n          return ref.type() === REFERENCE_CHILD_OF;\n        });\n\n        if (childRef) {\n          spanOptions.parentId = childRef.referencedContext().id;\n        }\n      }\n    }\n\n    var span;\n    var currentTransaction = this.transactionService.getCurrentTransaction();\n\n    if (currentTransaction) {\n      span = this.transactionService.startSpan(name, undefined, spanOptions);\n    } else {\n      span = this.transactionService.startTransaction(name, undefined, spanOptions);\n    }\n\n    if (!span) {\n      return new NoopSpan();\n    }\n\n    if (spanOptions.timestamp) {\n      span._start = spanOptions.timestamp - getTimeOrigin();\n    }\n\n    var otSpan = new Span(this, span);\n\n    if (options && options.tags) {\n      otSpan.addTags(options.tags);\n    }\n\n    return otSpan;\n  };\n\n  _proto._inject = function _inject(spanContext, format, carrier) {\n    switch (format) {\n      case FORMAT_TEXT_MAP:\n      case FORMAT_HTTP_HEADERS:\n        this.performanceMonitoring.injectDtHeader(spanContext, carrier);\n        break;\n\n      case FORMAT_BINARY:\n        if (__DEV__) {\n          this.loggingService.debug('Elastic APM OpenTracing: binary carrier format is not supported.');\n        }\n\n        break;\n    }\n  };\n\n  _proto._extract = function _extract(format, carrier) {\n    var ctx;\n\n    switch (format) {\n      case FORMAT_TEXT_MAP:\n      case FORMAT_HTTP_HEADERS:\n        ctx = this.performanceMonitoring.extractDtHeader(carrier);\n        break;\n\n      case FORMAT_BINARY:\n        if (__DEV__) {\n          this.loggingService.debug('Elastic APM OpenTracing: binary carrier format is not supported.');\n        }\n\n        break;\n    }\n\n    if (!ctx) {\n      ctx = null;\n    }\n\n    return ctx;\n  };\n\n  return Tracer;\n}(otTracer);\n\nexport default Tracer;","map":{"version":3,"sources":["/home/harish/windo/phoenix/node_modules/@elastic/apm-rum-core/dist/es/opentracing/tracer.js"],"names":["_inheritsLoose","subClass","superClass","prototype","Object","create","constructor","_setPrototypeOf","o","p","setPrototypeOf","__proto__","Tracer","otTracer","REFERENCE_CHILD_OF","FORMAT_TEXT_MAP","FORMAT_HTTP_HEADERS","FORMAT_BINARY","Span","NoopSpan","getTimeOrigin","find","__DEV__","_otTracer","performanceMonitoring","transactionService","loggingService","errorLogging","_this","call","_proto","_startSpan","name","options","spanOptions","managed","timestamp","startTime","childOf","parentId","id","references","length","debug","childRef","ref","type","referencedContext","span","currentTransaction","getCurrentTransaction","startSpan","undefined","startTransaction","_start","otSpan","tags","addTags","_inject","spanContext","format","carrier","injectDtHeader","_extract","ctx","extractDtHeader"],"mappings":"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","sourcesContent":["function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport { Tracer as otTracer } from 'opentracing/lib/tracer';\nimport { REFERENCE_CHILD_OF, FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, FORMAT_BINARY } from 'opentracing/lib/constants';\nimport { Span as NoopSpan } from 'opentracing/lib/span';\nimport { getTimeOrigin, find } from '../common/utils';\nimport { __DEV__ } from '../state';\nimport Span from './span';\n\nvar Tracer = function (_otTracer) {\n  _inheritsLoose(Tracer, _otTracer);\n\n  function Tracer(performanceMonitoring, transactionService, loggingService, errorLogging) {\n    var _this;\n\n    _this = _otTracer.call(this) || this;\n    _this.performanceMonitoring = performanceMonitoring;\n    _this.transactionService = transactionService;\n    _this.loggingService = loggingService;\n    _this.errorLogging = errorLogging;\n    return _this;\n  }\n\n  var _proto = Tracer.prototype;\n\n  _proto._startSpan = function _startSpan(name, options) {\n    var spanOptions = {\n      managed: true\n    };\n\n    if (options) {\n      spanOptions.timestamp = options.startTime;\n\n      if (options.childOf) {\n        spanOptions.parentId = options.childOf.id;\n      } else if (options.references && options.references.length > 0) {\n        if (options.references.length > 1) {\n          if (__DEV__) {\n            this.loggingService.debug('Elastic APM OpenTracing: Unsupported number of references, only the first childOf reference will be recorded.');\n          }\n        }\n\n        var childRef = find(options.references, function (ref) {\n          return ref.type() === REFERENCE_CHILD_OF;\n        });\n\n        if (childRef) {\n          spanOptions.parentId = childRef.referencedContext().id;\n        }\n      }\n    }\n\n    var span;\n    var currentTransaction = this.transactionService.getCurrentTransaction();\n\n    if (currentTransaction) {\n      span = this.transactionService.startSpan(name, undefined, spanOptions);\n    } else {\n      span = this.transactionService.startTransaction(name, undefined, spanOptions);\n    }\n\n    if (!span) {\n      return new NoopSpan();\n    }\n\n    if (spanOptions.timestamp) {\n      span._start = spanOptions.timestamp - getTimeOrigin();\n    }\n\n    var otSpan = new Span(this, span);\n\n    if (options && options.tags) {\n      otSpan.addTags(options.tags);\n    }\n\n    return otSpan;\n  };\n\n  _proto._inject = function _inject(spanContext, format, carrier) {\n    switch (format) {\n      case FORMAT_TEXT_MAP:\n      case FORMAT_HTTP_HEADERS:\n        this.performanceMonitoring.injectDtHeader(spanContext, carrier);\n        break;\n\n      case FORMAT_BINARY:\n        if (__DEV__) {\n          this.loggingService.debug('Elastic APM OpenTracing: binary carrier format is not supported.');\n        }\n\n        break;\n    }\n  };\n\n  _proto._extract = function _extract(format, carrier) {\n    var ctx;\n\n    switch (format) {\n      case FORMAT_TEXT_MAP:\n      case FORMAT_HTTP_HEADERS:\n        ctx = this.performanceMonitoring.extractDtHeader(carrier);\n        break;\n\n      case FORMAT_BINARY:\n        if (__DEV__) {\n          this.loggingService.debug('Elastic APM OpenTracing: binary carrier format is not supported.');\n        }\n\n        break;\n    }\n\n    if (!ctx) {\n      ctx = null;\n    }\n\n    return ctx;\n  };\n\n  return Tracer;\n}(otTracer);\n\nexport default Tracer;"]},"metadata":{},"sourceType":"module"}