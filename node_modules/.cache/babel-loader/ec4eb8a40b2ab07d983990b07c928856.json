{"ast":null,"code":"import { chunk } from 'lodash';\n/**\n * @param {Array<*>} array\n * @param {Function} fn\n * @param {*} thisArg\n * @param {Array<*>} args\n * @return {Promise<*>}\n */\n\nexport async function inParallel(array, fn, thisArg = null, args = []) {\n  const promises = array.map(item => fn.apply(thisArg, [item, ...args]));\n  return Promise.all(promises);\n}\n/**\n * @param {Array<*>} array\n * @param {Function} fn\n * @param {*} thisArg\n * @param {Array<*>} args\n * @return {Promise<*>}\n */\n\nexport async function inSeries(array, fn, thisArg = null, args = []) {\n  return array.reduce(async (acc, item) => {\n    const list = await acc;\n    const result = await fn.apply(thisArg, [item, ...args]);\n    list.push(result);\n    return list;\n  }, Promise.resolve([]));\n}\nexport async function inParallelWithLimit(list, concurrency, fn) {\n  const batches = chunk(list, concurrency);\n  const data = await inSeries(batches, async items => inParallel(items, fn));\n  return data.reduce((acc, items) => [...acc, ...items], []);\n}","map":{"version":3,"sources":["/home/harish/windo/phoenix/src/utils/parallel.js"],"names":["chunk","inParallel","array","fn","thisArg","args","promises","map","item","apply","Promise","all","inSeries","reduce","acc","list","result","push","resolve","inParallelWithLimit","concurrency","batches","data","items"],"mappings":"AAAA,SAASA,KAAT,QAAsB,QAAtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAeC,UAAf,CAA0BC,KAA1B,EAAiCC,EAAjC,EAAqCC,OAAO,GAAG,IAA/C,EAAqDC,IAAI,GAAG,EAA5D,EAAgE;AACrE,QAAMC,QAAQ,GAAGJ,KAAK,CAACK,GAAN,CAAUC,IAAI,IAAIL,EAAE,CAACM,KAAH,CAASL,OAAT,EAAkB,CAACI,IAAD,EAAO,GAAGH,IAAV,CAAlB,CAAlB,CAAjB;AACA,SAAOK,OAAO,CAACC,GAAR,CAAYL,QAAZ,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAeM,QAAf,CAAwBV,KAAxB,EAA+BC,EAA/B,EAAmCC,OAAO,GAAG,IAA7C,EAAmDC,IAAI,GAAG,EAA1D,EAA8D;AACnE,SAAOH,KAAK,CAACW,MAAN,CAAa,OAAOC,GAAP,EAAYN,IAAZ,KAAqB;AACvC,UAAMO,IAAI,GAAG,MAAMD,GAAnB;AACA,UAAME,MAAM,GAAG,MAAMb,EAAE,CAACM,KAAH,CAASL,OAAT,EAAkB,CAACI,IAAD,EAAO,GAAGH,IAAV,CAAlB,CAArB;AACAU,IAAAA,IAAI,CAACE,IAAL,CAAUD,MAAV;AACA,WAAOD,IAAP;AACD,GALM,EAKJL,OAAO,CAACQ,OAAR,CAAgB,EAAhB,CALI,CAAP;AAMD;AAED,OAAO,eAAeC,mBAAf,CAAmCJ,IAAnC,EAAyCK,WAAzC,EAAsDjB,EAAtD,EAA0D;AAC/D,QAAMkB,OAAO,GAAGrB,KAAK,CAACe,IAAD,EAAOK,WAAP,CAArB;AAEA,QAAME,IAAI,GAAG,MAAMV,QAAQ,CAACS,OAAD,EAAU,MAAME,KAAN,IAAetB,UAAU,CAACsB,KAAD,EAAQpB,EAAR,CAAnC,CAA3B;AACA,SAAOmB,IAAI,CAACT,MAAL,CAAY,CAACC,GAAD,EAAMS,KAAN,KAAgB,CAAC,GAAGT,GAAJ,EAAS,GAAGS,KAAZ,CAA5B,EAAgD,EAAhD,CAAP;AACD","sourcesContent":["import { chunk } from 'lodash';\n/**\n * @param {Array<*>} array\n * @param {Function} fn\n * @param {*} thisArg\n * @param {Array<*>} args\n * @return {Promise<*>}\n */\nexport async function inParallel(array, fn, thisArg = null, args = []) {\n  const promises = array.map(item => fn.apply(thisArg, [item, ...args]));\n  return Promise.all(promises);\n}\n\n/**\n * @param {Array<*>} array\n * @param {Function} fn\n * @param {*} thisArg\n * @param {Array<*>} args\n * @return {Promise<*>}\n */\nexport async function inSeries(array, fn, thisArg = null, args = []) {\n  return array.reduce(async (acc, item) => {\n    const list = await acc;\n    const result = await fn.apply(thisArg, [item, ...args]);\n    list.push(result);\n    return list;\n  }, Promise.resolve([]));\n}\n\nexport async function inParallelWithLimit(list, concurrency, fn) {\n  const batches = chunk(list, concurrency);\n\n  const data = await inSeries(batches, async items => inParallel(items, fn));\n  return data.reduce((acc, items) => [...acc, ...items], []);\n}\n"]},"metadata":{},"sourceType":"module"}