{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { fill, getFunctionName, getGlobalObject, getOriginalFunction } from '@sentry/utils';\nimport { wrap } from '../helpers';\nvar DEFAULT_EVENT_TARGET = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];\n/** Wrap timer functions and event targets to catch errors and provide better meta data */\n\nvar TryCatch =\n/** @class */\nfunction () {\n  /**\n   * @inheritDoc\n   */\n  function TryCatch(options) {\n    /**\n     * @inheritDoc\n     */\n    this.name = TryCatch.id;\n    this._options = __assign({\n      XMLHttpRequest: true,\n      eventTarget: true,\n      requestAnimationFrame: true,\n      setInterval: true,\n      setTimeout: true\n    }, options);\n  }\n  /**\n   * Wrap timer functions and event targets to catch errors\n   * and provide better metadata.\n   */\n\n\n  TryCatch.prototype.setupOnce = function () {\n    var global = getGlobalObject();\n\n    if (this._options.setTimeout) {\n      fill(global, 'setTimeout', _wrapTimeFunction);\n    }\n\n    if (this._options.setInterval) {\n      fill(global, 'setInterval', _wrapTimeFunction);\n    }\n\n    if (this._options.requestAnimationFrame) {\n      fill(global, 'requestAnimationFrame', _wrapRAF);\n    }\n\n    if (this._options.XMLHttpRequest && 'XMLHttpRequest' in global) {\n      fill(XMLHttpRequest.prototype, 'send', _wrapXHR);\n    }\n\n    var eventTargetOption = this._options.eventTarget;\n\n    if (eventTargetOption) {\n      var eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;\n      eventTarget.forEach(_wrapEventTarget);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  TryCatch.id = 'TryCatch';\n  return TryCatch;\n}();\n\nexport { TryCatch };\n/** JSDoc */\n\nfunction _wrapTimeFunction(original) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var originalCallback = args[0];\n    args[0] = wrap(originalCallback, {\n      mechanism: {\n        data: {\n          function: getFunctionName(original)\n        },\n        handled: true,\n        type: 'instrument'\n      }\n    });\n    return original.apply(this, args);\n  };\n}\n/** JSDoc */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction _wrapRAF(original) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (callback) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return original.call(this, wrap(callback, {\n      mechanism: {\n        data: {\n          function: 'requestAnimationFrame',\n          handler: getFunctionName(original)\n        },\n        handled: true,\n        type: 'instrument'\n      }\n    }));\n  };\n}\n/** JSDoc */\n\n\nfunction _wrapXHR(originalSend) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    } // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n\n    var xhr = this;\n    var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n    xmlHttpRequestProps.forEach(function (prop) {\n      if (prop in xhr && typeof xhr[prop] === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fill(xhr, prop, function (original) {\n          var wrapOptions = {\n            mechanism: {\n              data: {\n                function: prop,\n                handler: getFunctionName(original)\n              },\n              handled: true,\n              type: 'instrument'\n            }\n          }; // If Instrument integration has been called before TryCatch, get the name of original function\n\n          var originalFunction = getOriginalFunction(original);\n\n          if (originalFunction) {\n            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);\n          } // Otherwise wrap directly\n\n\n          return wrap(original, wrapOptions);\n        });\n      }\n    });\n    return originalSend.apply(this, args);\n  };\n}\n/** JSDoc */\n\n\nfunction _wrapEventTarget(target) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  var global = getGlobalObject(); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n  var proto = global[target] && global[target].prototype; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n\n  if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n    return;\n  }\n\n  fill(proto, 'addEventListener', function (original) {\n    return function (eventName, fn, options) {\n      try {\n        if (typeof fn.handleEvent === 'function') {\n          fn.handleEvent = wrap(fn.handleEvent.bind(fn), {\n            mechanism: {\n              data: {\n                function: 'handleEvent',\n                handler: getFunctionName(fn),\n                target: target\n              },\n              handled: true,\n              type: 'instrument'\n            }\n          });\n        }\n      } catch (err) {// can sometimes get 'Permission denied to access property \"handle Event'\n      }\n\n      return original.call(this, eventName, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      wrap(fn, {\n        mechanism: {\n          data: {\n            function: 'addEventListener',\n            handler: getFunctionName(fn),\n            target: target\n          },\n          handled: true,\n          type: 'instrument'\n        }\n      }), options);\n    };\n  });\n  fill(proto, 'removeEventListener', function (originalRemoveEventListener) {\n    return function (eventName, fn, options) {\n      /**\n       * There are 2 possible scenarios here:\n       *\n       * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n       * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n       * as a pass-through, and call original `removeEventListener` with it.\n       *\n       * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n       * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n       * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n       * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n       * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n       *\n       * When someone adds a handler prior to initialization, and then do it again, but after,\n       * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n       * to get rid of the initial handler and it'd stick there forever.\n       */\n      var wrappedEventHandler = fn;\n\n      try {\n        var originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;\n\n        if (originalEventHandler) {\n          originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n        }\n      } catch (e) {// ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n      }\n\n      return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);\n    };\n  });\n}","map":{"version":3,"sources":["../../src/integrations/trycatch.ts"],"names":[],"mappings":"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","sourcesContent":["import { Integration, WrappedFunction } from '@sentry/types';\nimport { fill, getFunctionName, getGlobalObject, getOriginalFunction } from '@sentry/utils';\n\nimport { wrap } from '../helpers';\n\nconst DEFAULT_EVENT_TARGET = [\n  'EventTarget',\n  'Window',\n  'Node',\n  'ApplicationCache',\n  'AudioTrackList',\n  'ChannelMergerNode',\n  'CryptoOperation',\n  'EventSource',\n  'FileReader',\n  'HTMLUnknownElement',\n  'IDBDatabase',\n  'IDBRequest',\n  'IDBTransaction',\n  'KeyOperation',\n  'MediaController',\n  'MessagePort',\n  'ModalWindow',\n  'Notification',\n  'SVGElementInstance',\n  'Screen',\n  'TextTrack',\n  'TextTrackCue',\n  'TextTrackList',\n  'WebSocket',\n  'WebSocketWorker',\n  'Worker',\n  'XMLHttpRequest',\n  'XMLHttpRequestEventTarget',\n  'XMLHttpRequestUpload',\n];\n\ntype XMLHttpRequestProp = 'onload' | 'onerror' | 'onprogress' | 'onreadystatechange';\n\n/** JSDoc */\ninterface TryCatchOptions {\n  setTimeout: boolean;\n  setInterval: boolean;\n  requestAnimationFrame: boolean;\n  XMLHttpRequest: boolean;\n  eventTarget: boolean | string[];\n}\n\n/** Wrap timer functions and event targets to catch errors and provide better meta data */\nexport class TryCatch implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'TryCatch';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = TryCatch.id;\n\n  /** JSDoc */\n  private readonly _options: TryCatchOptions;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options?: Partial<TryCatchOptions>) {\n    this._options = {\n      XMLHttpRequest: true,\n      eventTarget: true,\n      requestAnimationFrame: true,\n      setInterval: true,\n      setTimeout: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Wrap timer functions and event targets to catch errors\n   * and provide better metadata.\n   */\n  public setupOnce(): void {\n    const global = getGlobalObject();\n\n    if (this._options.setTimeout) {\n      fill(global, 'setTimeout', _wrapTimeFunction);\n    }\n\n    if (this._options.setInterval) {\n      fill(global, 'setInterval', _wrapTimeFunction);\n    }\n\n    if (this._options.requestAnimationFrame) {\n      fill(global, 'requestAnimationFrame', _wrapRAF);\n    }\n\n    if (this._options.XMLHttpRequest && 'XMLHttpRequest' in global) {\n      fill(XMLHttpRequest.prototype, 'send', _wrapXHR);\n    }\n\n    const eventTargetOption = this._options.eventTarget;\n    if (eventTargetOption) {\n      const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;\n      eventTarget.forEach(_wrapEventTarget);\n    }\n  }\n}\n\n/** JSDoc */\nfunction _wrapTimeFunction(original: () => void): () => number {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (this: any, ...args: any[]): number {\n    const originalCallback = args[0];\n    args[0] = wrap(originalCallback, {\n      mechanism: {\n        data: { function: getFunctionName(original) },\n        handled: true,\n        type: 'instrument',\n      },\n    });\n    return original.apply(this, args);\n  };\n}\n\n/** JSDoc */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _wrapRAF(original: any): (callback: () => void) => any {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (this: any, callback: () => void): () => void {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return original.call(\n      this,\n      wrap(callback, {\n        mechanism: {\n          data: {\n            function: 'requestAnimationFrame',\n            handler: getFunctionName(original),\n          },\n          handled: true,\n          type: 'instrument',\n        },\n      }),\n    );\n  };\n}\n\n/** JSDoc */\nfunction _wrapXHR(originalSend: () => void): () => void {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (this: XMLHttpRequest, ...args: any[]): void {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const xhr = this;\n    const xmlHttpRequestProps: XMLHttpRequestProp[] = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n\n    xmlHttpRequestProps.forEach(prop => {\n      if (prop in xhr && typeof xhr[prop] === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fill(xhr, prop, function (original: WrappedFunction): () => any {\n          const wrapOptions = {\n            mechanism: {\n              data: {\n                function: prop,\n                handler: getFunctionName(original),\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          };\n\n          // If Instrument integration has been called before TryCatch, get the name of original function\n          const originalFunction = getOriginalFunction(original);\n          if (originalFunction) {\n            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);\n          }\n\n          // Otherwise wrap directly\n          return wrap(original, wrapOptions);\n        });\n      }\n    });\n\n    return originalSend.apply(this, args);\n  };\n}\n\n/** JSDoc */\nfunction _wrapEventTarget(target: string): void {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const global = getGlobalObject() as { [key: string]: any };\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  const proto = global[target] && global[target].prototype;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n  if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n    return;\n  }\n\n  fill(proto, 'addEventListener', function (original: () => void): (\n    eventName: string,\n    fn: EventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ) => void {\n    return function (\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this: any,\n      eventName: string,\n      fn: EventListenerObject,\n      options?: boolean | AddEventListenerOptions,\n    ): (eventName: string, fn: EventListenerObject, capture?: boolean, secure?: boolean) => void {\n      try {\n        if (typeof fn.handleEvent === 'function') {\n          fn.handleEvent = wrap(fn.handleEvent.bind(fn), {\n            mechanism: {\n              data: {\n                function: 'handleEvent',\n                handler: getFunctionName(fn),\n                target,\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          });\n        }\n      } catch (err) {\n        // can sometimes get 'Permission denied to access property \"handle Event'\n      }\n\n      return original.call(\n        this,\n        eventName,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        wrap(fn as any as WrappedFunction, {\n          mechanism: {\n            data: {\n              function: 'addEventListener',\n              handler: getFunctionName(fn),\n              target,\n            },\n            handled: true,\n            type: 'instrument',\n          },\n        }),\n        options,\n      );\n    };\n  });\n\n  fill(\n    proto,\n    'removeEventListener',\n    function (\n      originalRemoveEventListener: () => void,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): (this: any, eventName: string, fn: EventListenerObject, options?: boolean | EventListenerOptions) => () => void {\n      return function (\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this: any,\n        eventName: string,\n        fn: EventListenerObject,\n        options?: boolean | EventListenerOptions,\n      ): () => void {\n        /**\n         * There are 2 possible scenarios here:\n         *\n         * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n         * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n         * as a pass-through, and call original `removeEventListener` with it.\n         *\n         * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n         * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n         * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n         * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n         * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n         *\n         * When someone adds a handler prior to initialization, and then do it again, but after,\n         * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n         * to get rid of the initial handler and it'd stick there forever.\n         */\n        const wrappedEventHandler = fn as unknown as WrappedFunction;\n        try {\n          const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;\n          if (originalEventHandler) {\n            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n          }\n        } catch (e) {\n          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);\n      };\n    },\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}