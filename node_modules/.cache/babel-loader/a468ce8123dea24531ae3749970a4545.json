{"ast":null,"code":"import { logger } from '@sentry/utils';\n/** Deduplication filter */\n\nvar Dedupe =\n/** @class */\nfunction () {\n  function Dedupe() {\n    /**\n     * @inheritDoc\n     */\n    this.name = Dedupe.id;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  Dedupe.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {\n    addGlobalEventProcessor(function (currentEvent) {\n      var self = getCurrentHub().getIntegration(Dedupe);\n\n      if (self) {\n        // Juuust in case something goes wrong\n        try {\n          if (_shouldDropEvent(currentEvent, self._previousEvent)) {\n            logger.warn(\"Event dropped due to being a duplicate of previously captured event.\");\n            return null;\n          }\n        } catch (_oO) {\n          return self._previousEvent = currentEvent;\n        }\n\n        return self._previousEvent = currentEvent;\n      }\n\n      return currentEvent;\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Dedupe.id = 'Dedupe';\n  return Dedupe;\n}();\n\nexport { Dedupe };\n/** JSDoc */\n\nfunction _shouldDropEvent(currentEvent, previousEvent) {\n  if (!previousEvent) {\n    return false;\n  }\n\n  if (_isSameMessageEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  if (_isSameExceptionEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  return false;\n}\n/** JSDoc */\n\n\nfunction _isSameMessageEvent(currentEvent, previousEvent) {\n  var currentMessage = currentEvent.message;\n  var previousMessage = previousEvent.message; // If neither event has a message property, they were both exceptions, so bail out\n\n  if (!currentMessage && !previousMessage) {\n    return false;\n  } // If only one event has a stacktrace, but not the other one, they are not the same\n\n\n  if (currentMessage && !previousMessage || !currentMessage && previousMessage) {\n    return false;\n  }\n\n  if (currentMessage !== previousMessage) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n/** JSDoc */\n\n\nfunction _isSameExceptionEvent(currentEvent, previousEvent) {\n  var previousException = _getExceptionFromEvent(previousEvent);\n\n  var currentException = _getExceptionFromEvent(currentEvent);\n\n  if (!previousException || !currentException) {\n    return false;\n  }\n\n  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n/** JSDoc */\n\n\nfunction _isSameStacktrace(currentEvent, previousEvent) {\n  var currentFrames = _getFramesFromEvent(currentEvent);\n\n  var previousFrames = _getFramesFromEvent(previousEvent); // If neither event has a stacktrace, they are assumed to be the same\n\n\n  if (!currentFrames && !previousFrames) {\n    return true;\n  } // If only one event has a stacktrace, but not the other one, they are not the same\n\n\n  if (currentFrames && !previousFrames || !currentFrames && previousFrames) {\n    return false;\n  }\n\n  currentFrames = currentFrames;\n  previousFrames = previousFrames; // If number of frames differ, they are not the same\n\n  if (previousFrames.length !== currentFrames.length) {\n    return false;\n  } // Otherwise, compare the two\n\n\n  for (var i = 0; i < previousFrames.length; i++) {\n    var frameA = previousFrames[i];\n    var frameB = currentFrames[i];\n\n    if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/** JSDoc */\n\n\nfunction _isSameFingerprint(currentEvent, previousEvent) {\n  var currentFingerprint = currentEvent.fingerprint;\n  var previousFingerprint = previousEvent.fingerprint; // If neither event has a fingerprint, they are assumed to be the same\n\n  if (!currentFingerprint && !previousFingerprint) {\n    return true;\n  } // If only one event has a fingerprint, but not the other one, they are not the same\n\n\n  if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {\n    return false;\n  }\n\n  currentFingerprint = currentFingerprint;\n  previousFingerprint = previousFingerprint; // Otherwise, compare the two\n\n  try {\n    return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n  } catch (_oO) {\n    return false;\n  }\n}\n/** JSDoc */\n\n\nfunction _getExceptionFromEvent(event) {\n  return event.exception && event.exception.values && event.exception.values[0];\n}\n/** JSDoc */\n\n\nfunction _getFramesFromEvent(event) {\n  var exception = event.exception;\n\n  if (exception) {\n    try {\n      // @ts-ignore Object could be undefined\n      return exception.values[0].stacktrace.frames;\n    } catch (_oO) {\n      return undefined;\n    }\n  } else if (event.stacktrace) {\n    return event.stacktrace.frames;\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../src/integrations/dedupe.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, EventProcessor, Exception, Hub, Integration, StackFrame } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\n/** Deduplication filter */\nexport class Dedupe implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Dedupe';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Dedupe.id;\n\n  /**\n   * @inheritDoc\n   */\n  private _previousEvent?: Event;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    addGlobalEventProcessor((currentEvent: Event) => {\n      const self = getCurrentHub().getIntegration(Dedupe);\n      if (self) {\n        // Juuust in case something goes wrong\n        try {\n          if (_shouldDropEvent(currentEvent, self._previousEvent)) {\n            logger.warn(`Event dropped due to being a duplicate of previously captured event.`);\n            return null;\n          }\n        } catch (_oO) {\n          return (self._previousEvent = currentEvent);\n        }\n\n        return (self._previousEvent = currentEvent);\n      }\n      return currentEvent;\n    });\n  }\n}\n\n/** JSDoc */\nfunction _shouldDropEvent(currentEvent: Event, previousEvent?: Event): boolean {\n  if (!previousEvent) {\n    return false;\n  }\n\n  if (_isSameMessageEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  if (_isSameExceptionEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  return false;\n}\n\n/** JSDoc */\nfunction _isSameMessageEvent(currentEvent: Event, previousEvent: Event): boolean {\n  const currentMessage = currentEvent.message;\n  const previousMessage = previousEvent.message;\n\n  // If neither event has a message property, they were both exceptions, so bail out\n  if (!currentMessage && !previousMessage) {\n    return false;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {\n    return false;\n  }\n\n  if (currentMessage !== previousMessage) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\n/** JSDoc */\nfunction _isSameExceptionEvent(currentEvent: Event, previousEvent: Event): boolean {\n  const previousException = _getExceptionFromEvent(previousEvent);\n  const currentException = _getExceptionFromEvent(currentEvent);\n\n  if (!previousException || !currentException) {\n    return false;\n  }\n\n  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\n/** JSDoc */\nfunction _isSameStacktrace(currentEvent: Event, previousEvent: Event): boolean {\n  let currentFrames = _getFramesFromEvent(currentEvent);\n  let previousFrames = _getFramesFromEvent(previousEvent);\n\n  // If neither event has a stacktrace, they are assumed to be the same\n  if (!currentFrames && !previousFrames) {\n    return true;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {\n    return false;\n  }\n\n  currentFrames = currentFrames as StackFrame[];\n  previousFrames = previousFrames as StackFrame[];\n\n  // If number of frames differ, they are not the same\n  if (previousFrames.length !== currentFrames.length) {\n    return false;\n  }\n\n  // Otherwise, compare the two\n  for (let i = 0; i < previousFrames.length; i++) {\n    const frameA = previousFrames[i];\n    const frameB = currentFrames[i];\n\n    if (\n      frameA.filename !== frameB.filename ||\n      frameA.lineno !== frameB.lineno ||\n      frameA.colno !== frameB.colno ||\n      frameA.function !== frameB.function\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/** JSDoc */\nfunction _isSameFingerprint(currentEvent: Event, previousEvent: Event): boolean {\n  let currentFingerprint = currentEvent.fingerprint;\n  let previousFingerprint = previousEvent.fingerprint;\n\n  // If neither event has a fingerprint, they are assumed to be the same\n  if (!currentFingerprint && !previousFingerprint) {\n    return true;\n  }\n\n  // If only one event has a fingerprint, but not the other one, they are not the same\n  if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {\n    return false;\n  }\n\n  currentFingerprint = currentFingerprint as string[];\n  previousFingerprint = previousFingerprint as string[];\n\n  // Otherwise, compare the two\n  try {\n    return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n  } catch (_oO) {\n    return false;\n  }\n}\n\n/** JSDoc */\nfunction _getExceptionFromEvent(event: Event): Exception | undefined {\n  return event.exception && event.exception.values && event.exception.values[0];\n}\n\n/** JSDoc */\nfunction _getFramesFromEvent(event: Event): StackFrame[] | undefined {\n  const exception = event.exception;\n\n  if (exception) {\n    try {\n      // @ts-ignore Object could be undefined\n      return exception.values[0].stacktrace.frames;\n    } catch (_oO) {\n      return undefined;\n    }\n  } else if (event.stacktrace) {\n    return event.stacktrace.frames;\n  }\n  return undefined;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}