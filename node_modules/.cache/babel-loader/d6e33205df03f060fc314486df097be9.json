{"ast":null,"code":"import { LONG_TASK, LARGEST_CONTENTFUL_PAINT, FIRST_CONTENTFUL_PAINT, FIRST_INPUT, LAYOUT_SHIFT } from '../common/constants';\nimport { noop, PERF } from '../common/utils';\nimport Span from './span';\nexport var metrics = {\n  fid: 0,\n  fcp: 0,\n  tbt: {\n    start: Infinity,\n    duration: 0\n  },\n  cls: {\n    score: 0,\n    firstEntryTime: Number.NEGATIVE_INFINITY,\n    prevEntryTime: Number.NEGATIVE_INFINITY,\n    currentSessionScore: 0\n  },\n  longtask: {\n    count: 0,\n    duration: 0,\n    max: 0\n  }\n};\nvar LONG_TASK_THRESHOLD = 50;\nexport function createLongTaskSpans(longtasks, agg) {\n  var spans = [];\n\n  for (var i = 0; i < longtasks.length; i++) {\n    var _longtasks$i = longtasks[i],\n        name = _longtasks$i.name,\n        startTime = _longtasks$i.startTime,\n        duration = _longtasks$i.duration,\n        attribution = _longtasks$i.attribution;\n    var end = startTime + duration;\n    var span = new Span(\"Longtask(\" + name + \")\", LONG_TASK, {\n      startTime: startTime\n    });\n    agg.count++;\n    agg.duration += duration;\n    agg.max = Math.max(duration, agg.max);\n\n    if (attribution.length > 0) {\n      var _attribution$ = attribution[0],\n          _name = _attribution$.name,\n          containerType = _attribution$.containerType,\n          containerName = _attribution$.containerName,\n          containerId = _attribution$.containerId;\n      var customContext = {\n        attribution: _name,\n        type: containerType\n      };\n\n      if (containerName) {\n        customContext.name = containerName;\n      }\n\n      if (containerId) {\n        customContext.id = containerId;\n      }\n\n      span.addContext({\n        custom: customContext\n      });\n    }\n\n    span.end(end);\n    spans.push(span);\n  }\n\n  return spans;\n}\nexport function createFirstInputDelaySpan(fidEntries) {\n  var firstInput = fidEntries[0];\n\n  if (firstInput) {\n    var startTime = firstInput.startTime,\n        processingStart = firstInput.processingStart;\n    var span = new Span('First Input Delay', FIRST_INPUT, {\n      startTime: startTime\n    });\n    span.end(processingStart);\n    return span;\n  }\n}\nexport function createTotalBlockingTimeSpan(tbtObject) {\n  var start = tbtObject.start,\n      duration = tbtObject.duration;\n  var tbtSpan = new Span('Total Blocking Time', LONG_TASK, {\n    startTime: start\n  });\n  tbtSpan.end(start + duration);\n  return tbtSpan;\n}\nexport function calculateTotalBlockingTime(longtaskEntries) {\n  longtaskEntries.forEach(function (entry) {\n    var name = entry.name,\n        startTime = entry.startTime,\n        duration = entry.duration;\n\n    if (startTime < metrics.fcp) {\n      return;\n    }\n\n    if (name !== 'self' && name.indexOf('same-origin') === -1) {\n      return;\n    }\n\n    metrics.tbt.start = Math.min(metrics.tbt.start, startTime);\n    var blockingTime = duration - LONG_TASK_THRESHOLD;\n\n    if (blockingTime > 0) {\n      metrics.tbt.duration += blockingTime;\n    }\n  });\n}\nexport function calculateCumulativeLayoutShift(clsEntries) {\n  clsEntries.forEach(function (entry) {\n    if (!entry.hadRecentInput && entry.value) {\n      var shouldCreateNewSession = entry.startTime - metrics.cls.firstEntryTime > 5000 || entry.startTime - metrics.cls.prevEntryTime > 1000;\n\n      if (shouldCreateNewSession) {\n        metrics.cls.firstEntryTime = entry.startTime;\n        metrics.cls.currentSessionScore = 0;\n      }\n\n      metrics.cls.prevEntryTime = entry.startTime;\n      metrics.cls.currentSessionScore += entry.value;\n      metrics.cls.score = Math.max(metrics.cls.score, metrics.cls.currentSessionScore);\n    }\n  });\n}\nexport function captureObserverEntries(list, _ref) {\n  var isHardNavigation = _ref.isHardNavigation,\n      trStart = _ref.trStart;\n  var longtaskEntries = list.getEntriesByType(LONG_TASK).filter(function (entry) {\n    return entry.startTime >= trStart;\n  });\n  var longTaskSpans = createLongTaskSpans(longtaskEntries, metrics.longtask);\n  var result = {\n    spans: longTaskSpans,\n    marks: {}\n  };\n\n  if (!isHardNavigation) {\n    return result;\n  }\n\n  var lcpEntries = list.getEntriesByType(LARGEST_CONTENTFUL_PAINT);\n  var lastLcpEntry = lcpEntries[lcpEntries.length - 1];\n\n  if (lastLcpEntry) {\n    var lcp = parseInt(lastLcpEntry.startTime);\n    metrics.lcp = lcp;\n    result.marks.largestContentfulPaint = lcp;\n  }\n\n  var timing = PERF.timing;\n  var unloadDiff = timing.fetchStart - timing.navigationStart;\n  var fcpEntry = list.getEntriesByName(FIRST_CONTENTFUL_PAINT)[0];\n\n  if (fcpEntry) {\n    var fcp = parseInt(unloadDiff >= 0 ? fcpEntry.startTime - unloadDiff : fcpEntry.startTime);\n    metrics.fcp = fcp;\n    result.marks.firstContentfulPaint = fcp;\n  }\n\n  var fidEntries = list.getEntriesByType(FIRST_INPUT);\n  var fidSpan = createFirstInputDelaySpan(fidEntries);\n\n  if (fidSpan) {\n    metrics.fid = fidSpan.duration();\n    result.spans.push(fidSpan);\n  }\n\n  calculateTotalBlockingTime(longtaskEntries);\n  var clsEntries = list.getEntriesByType(LAYOUT_SHIFT);\n  calculateCumulativeLayoutShift(clsEntries);\n  return result;\n}\nexport var PerfEntryRecorder = function () {\n  function PerfEntryRecorder(callback) {\n    this.po = {\n      observe: noop,\n      disconnect: noop\n    };\n\n    if (window.PerformanceObserver) {\n      this.po = new PerformanceObserver(callback);\n    }\n  }\n\n  var _proto = PerfEntryRecorder.prototype;\n\n  _proto.start = function start(type) {\n    try {\n      this.po.observe({\n        type: type,\n        buffered: true\n      });\n    } catch (_) {}\n  };\n\n  _proto.stop = function stop() {\n    this.po.disconnect();\n  };\n\n  return PerfEntryRecorder;\n}();","map":{"version":3,"sources":["/home/harish/windo/phoenix/node_modules/@elastic/apm-rum-core/dist/es/performance-monitoring/metrics.js"],"names":["LONG_TASK","LARGEST_CONTENTFUL_PAINT","FIRST_CONTENTFUL_PAINT","FIRST_INPUT","LAYOUT_SHIFT","noop","PERF","Span","metrics","fid","fcp","tbt","start","Infinity","duration","cls","score","firstEntryTime","Number","NEGATIVE_INFINITY","prevEntryTime","currentSessionScore","longtask","count","max","LONG_TASK_THRESHOLD","createLongTaskSpans","longtasks","agg","spans","i","length","_longtasks$i","name","startTime","attribution","end","span","Math","_attribution$","_name","containerType","containerName","containerId","customContext","type","id","addContext","custom","push","createFirstInputDelaySpan","fidEntries","firstInput","processingStart","createTotalBlockingTimeSpan","tbtObject","tbtSpan","calculateTotalBlockingTime","longtaskEntries","forEach","entry","indexOf","min","blockingTime","calculateCumulativeLayoutShift","clsEntries","hadRecentInput","value","shouldCreateNewSession","captureObserverEntries","list","_ref","isHardNavigation","trStart","getEntriesByType","filter","longTaskSpans","result","marks","lcpEntries","lastLcpEntry","lcp","parseInt","largestContentfulPaint","timing","unloadDiff","fetchStart","navigationStart","fcpEntry","getEntriesByName","firstContentfulPaint","fidSpan","PerfEntryRecorder","callback","po","observe","disconnect","window","PerformanceObserver","_proto","prototype","buffered","_","stop"],"mappings":"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","sourcesContent":["import { LONG_TASK, LARGEST_CONTENTFUL_PAINT, FIRST_CONTENTFUL_PAINT, FIRST_INPUT, LAYOUT_SHIFT } from '../common/constants';\nimport { noop, PERF } from '../common/utils';\nimport Span from './span';\nexport var metrics = {\n  fid: 0,\n  fcp: 0,\n  tbt: {\n    start: Infinity,\n    duration: 0\n  },\n  cls: {\n    score: 0,\n    firstEntryTime: Number.NEGATIVE_INFINITY,\n    prevEntryTime: Number.NEGATIVE_INFINITY,\n    currentSessionScore: 0\n  },\n  longtask: {\n    count: 0,\n    duration: 0,\n    max: 0\n  }\n};\nvar LONG_TASK_THRESHOLD = 50;\nexport function createLongTaskSpans(longtasks, agg) {\n  var spans = [];\n\n  for (var i = 0; i < longtasks.length; i++) {\n    var _longtasks$i = longtasks[i],\n        name = _longtasks$i.name,\n        startTime = _longtasks$i.startTime,\n        duration = _longtasks$i.duration,\n        attribution = _longtasks$i.attribution;\n    var end = startTime + duration;\n    var span = new Span(\"Longtask(\" + name + \")\", LONG_TASK, {\n      startTime: startTime\n    });\n    agg.count++;\n    agg.duration += duration;\n    agg.max = Math.max(duration, agg.max);\n\n    if (attribution.length > 0) {\n      var _attribution$ = attribution[0],\n          _name = _attribution$.name,\n          containerType = _attribution$.containerType,\n          containerName = _attribution$.containerName,\n          containerId = _attribution$.containerId;\n      var customContext = {\n        attribution: _name,\n        type: containerType\n      };\n\n      if (containerName) {\n        customContext.name = containerName;\n      }\n\n      if (containerId) {\n        customContext.id = containerId;\n      }\n\n      span.addContext({\n        custom: customContext\n      });\n    }\n\n    span.end(end);\n    spans.push(span);\n  }\n\n  return spans;\n}\nexport function createFirstInputDelaySpan(fidEntries) {\n  var firstInput = fidEntries[0];\n\n  if (firstInput) {\n    var startTime = firstInput.startTime,\n        processingStart = firstInput.processingStart;\n    var span = new Span('First Input Delay', FIRST_INPUT, {\n      startTime: startTime\n    });\n    span.end(processingStart);\n    return span;\n  }\n}\nexport function createTotalBlockingTimeSpan(tbtObject) {\n  var start = tbtObject.start,\n      duration = tbtObject.duration;\n  var tbtSpan = new Span('Total Blocking Time', LONG_TASK, {\n    startTime: start\n  });\n  tbtSpan.end(start + duration);\n  return tbtSpan;\n}\nexport function calculateTotalBlockingTime(longtaskEntries) {\n  longtaskEntries.forEach(function (entry) {\n    var name = entry.name,\n        startTime = entry.startTime,\n        duration = entry.duration;\n\n    if (startTime < metrics.fcp) {\n      return;\n    }\n\n    if (name !== 'self' && name.indexOf('same-origin') === -1) {\n      return;\n    }\n\n    metrics.tbt.start = Math.min(metrics.tbt.start, startTime);\n    var blockingTime = duration - LONG_TASK_THRESHOLD;\n\n    if (blockingTime > 0) {\n      metrics.tbt.duration += blockingTime;\n    }\n  });\n}\nexport function calculateCumulativeLayoutShift(clsEntries) {\n  clsEntries.forEach(function (entry) {\n    if (!entry.hadRecentInput && entry.value) {\n      var shouldCreateNewSession = entry.startTime - metrics.cls.firstEntryTime > 5000 || entry.startTime - metrics.cls.prevEntryTime > 1000;\n\n      if (shouldCreateNewSession) {\n        metrics.cls.firstEntryTime = entry.startTime;\n        metrics.cls.currentSessionScore = 0;\n      }\n\n      metrics.cls.prevEntryTime = entry.startTime;\n      metrics.cls.currentSessionScore += entry.value;\n      metrics.cls.score = Math.max(metrics.cls.score, metrics.cls.currentSessionScore);\n    }\n  });\n}\nexport function captureObserverEntries(list, _ref) {\n  var isHardNavigation = _ref.isHardNavigation,\n      trStart = _ref.trStart;\n  var longtaskEntries = list.getEntriesByType(LONG_TASK).filter(function (entry) {\n    return entry.startTime >= trStart;\n  });\n  var longTaskSpans = createLongTaskSpans(longtaskEntries, metrics.longtask);\n  var result = {\n    spans: longTaskSpans,\n    marks: {}\n  };\n\n  if (!isHardNavigation) {\n    return result;\n  }\n\n  var lcpEntries = list.getEntriesByType(LARGEST_CONTENTFUL_PAINT);\n  var lastLcpEntry = lcpEntries[lcpEntries.length - 1];\n\n  if (lastLcpEntry) {\n    var lcp = parseInt(lastLcpEntry.startTime);\n    metrics.lcp = lcp;\n    result.marks.largestContentfulPaint = lcp;\n  }\n\n  var timing = PERF.timing;\n  var unloadDiff = timing.fetchStart - timing.navigationStart;\n  var fcpEntry = list.getEntriesByName(FIRST_CONTENTFUL_PAINT)[0];\n\n  if (fcpEntry) {\n    var fcp = parseInt(unloadDiff >= 0 ? fcpEntry.startTime - unloadDiff : fcpEntry.startTime);\n    metrics.fcp = fcp;\n    result.marks.firstContentfulPaint = fcp;\n  }\n\n  var fidEntries = list.getEntriesByType(FIRST_INPUT);\n  var fidSpan = createFirstInputDelaySpan(fidEntries);\n\n  if (fidSpan) {\n    metrics.fid = fidSpan.duration();\n    result.spans.push(fidSpan);\n  }\n\n  calculateTotalBlockingTime(longtaskEntries);\n  var clsEntries = list.getEntriesByType(LAYOUT_SHIFT);\n  calculateCumulativeLayoutShift(clsEntries);\n  return result;\n}\nexport var PerfEntryRecorder = function () {\n  function PerfEntryRecorder(callback) {\n    this.po = {\n      observe: noop,\n      disconnect: noop\n    };\n\n    if (window.PerformanceObserver) {\n      this.po = new PerformanceObserver(callback);\n    }\n  }\n\n  var _proto = PerfEntryRecorder.prototype;\n\n  _proto.start = function start(type) {\n    try {\n      this.po.observe({\n        type: type,\n        buffered: true\n      });\n    } catch (_) {}\n  };\n\n  _proto.stop = function stop() {\n    this.po.disconnect();\n  };\n\n  return PerfEntryRecorder;\n}();"]},"metadata":{},"sourceType":"module"}