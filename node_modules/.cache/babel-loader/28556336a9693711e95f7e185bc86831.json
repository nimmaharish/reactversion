{"ast":null,"code":"import { Promise } from '../polyfills';\nimport { globalState } from './patch-utils';\nimport { SCHEDULE, INVOKE, FETCH } from '../constants';\nimport { scheduleMicroTask } from '../utils';\nexport function patchFetch(callback) {\n  if (!window.fetch || !window.Request) {\n    return;\n  }\n\n  function scheduleTask(task) {\n    task.state = SCHEDULE;\n    callback(SCHEDULE, task);\n  }\n\n  function invokeTask(task) {\n    task.state = INVOKE;\n    callback(INVOKE, task);\n  }\n\n  var nativeFetch = window.fetch;\n\n  window.fetch = function (input, init) {\n    var fetchSelf = this;\n    var args = arguments;\n    var request, url;\n\n    if (typeof input === 'string') {\n      request = new Request(input, init);\n      url = input;\n    } else if (input) {\n      request = input;\n      url = request.url;\n    } else {\n      return nativeFetch.apply(fetchSelf, args);\n    }\n\n    var task = {\n      source: FETCH,\n      state: '',\n      type: 'macroTask',\n      data: {\n        target: request,\n        method: request.method,\n        url: url,\n        aborted: false\n      }\n    };\n    return new Promise(function (resolve, reject) {\n      globalState.fetchInProgress = true;\n      scheduleTask(task);\n      var promise;\n\n      try {\n        promise = nativeFetch.apply(fetchSelf, [request]);\n      } catch (error) {\n        reject(error);\n        task.data.error = error;\n        invokeTask(task);\n        globalState.fetchInProgress = false;\n        return;\n      }\n\n      promise.then(function (response) {\n        resolve(response);\n        scheduleMicroTask(function () {\n          task.data.response = response;\n          invokeTask(task);\n        });\n      }, function (error) {\n        reject(error);\n        scheduleMicroTask(function () {\n          task.data.error = error;\n          invokeTask(task);\n        });\n      });\n      globalState.fetchInProgress = false;\n    });\n  };\n}","map":{"version":3,"sources":["/home/harish/windo/phoenix/node_modules/@elastic/apm-rum-core/dist/es/common/patching/fetch-patch.js"],"names":["Promise","globalState","SCHEDULE","INVOKE","FETCH","scheduleMicroTask","patchFetch","callback","window","fetch","Request","scheduleTask","task","state","invokeTask","nativeFetch","input","init","fetchSelf","args","arguments","request","url","apply","source","type","data","target","method","aborted","resolve","reject","fetchInProgress","promise","error","then","response"],"mappings":"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","sourcesContent":["import { Promise } from '../polyfills';\nimport { globalState } from './patch-utils';\nimport { SCHEDULE, INVOKE, FETCH } from '../constants';\nimport { scheduleMicroTask } from '../utils';\nexport function patchFetch(callback) {\n  if (!window.fetch || !window.Request) {\n    return;\n  }\n\n  function scheduleTask(task) {\n    task.state = SCHEDULE;\n    callback(SCHEDULE, task);\n  }\n\n  function invokeTask(task) {\n    task.state = INVOKE;\n    callback(INVOKE, task);\n  }\n\n  var nativeFetch = window.fetch;\n\n  window.fetch = function (input, init) {\n    var fetchSelf = this;\n    var args = arguments;\n    var request, url;\n\n    if (typeof input === 'string') {\n      request = new Request(input, init);\n      url = input;\n    } else if (input) {\n      request = input;\n      url = request.url;\n    } else {\n      return nativeFetch.apply(fetchSelf, args);\n    }\n\n    var task = {\n      source: FETCH,\n      state: '',\n      type: 'macroTask',\n      data: {\n        target: request,\n        method: request.method,\n        url: url,\n        aborted: false\n      }\n    };\n    return new Promise(function (resolve, reject) {\n      globalState.fetchInProgress = true;\n      scheduleTask(task);\n      var promise;\n\n      try {\n        promise = nativeFetch.apply(fetchSelf, [request]);\n      } catch (error) {\n        reject(error);\n        task.data.error = error;\n        invokeTask(task);\n        globalState.fetchInProgress = false;\n        return;\n      }\n\n      promise.then(function (response) {\n        resolve(response);\n        scheduleMicroTask(function () {\n          task.data.response = response;\n          invokeTask(task);\n        });\n      }, function (error) {\n        reject(error);\n        scheduleMicroTask(function () {\n          task.data.error = error;\n          invokeTask(task);\n        });\n      });\n      globalState.fetchInProgress = false;\n    });\n  };\n}"]},"metadata":{},"sourceType":"module"}