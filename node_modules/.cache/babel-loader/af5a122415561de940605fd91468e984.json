{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar noop = require(\"./noop\");\n/**\n * Span represents a logical unit of work as part of a broader Trace. Examples\n * of span might include remote procedure calls or a in-process function calls\n * to sub-components. A Trace has a single, top-level \"root\" Span that in turn\n * may have zero or more child Spans, which in turn may have children.\n */\n\n\nvar Span =\n/** @class */\nfunction () {\n  function Span() {} // ---------------------------------------------------------------------- //\n  // OpenTracing API methods\n  // ---------------------------------------------------------------------- //\n\n  /**\n   * Returns the SpanContext object associated with this Span.\n   *\n   * @return {SpanContext}\n   */\n\n\n  Span.prototype.context = function () {\n    return this._context();\n  };\n  /**\n   * Returns the Tracer object used to create this Span.\n   *\n   * @return {Tracer}\n   */\n\n\n  Span.prototype.tracer = function () {\n    return this._tracer();\n  };\n  /**\n   * Sets the string name for the logical operation this span represents.\n   *\n   * @param {string} name\n   */\n\n\n  Span.prototype.setOperationName = function (name) {\n    this._setOperationName(name);\n\n    return this;\n  };\n  /**\n   * Sets a key:value pair on this Span that also propagates to future\n   * children of the associated Span.\n   *\n   * setBaggageItem() enables powerful functionality given a full-stack\n   * opentracing integration (e.g., arbitrary application data from a web\n   * client can make it, transparently, all the way into the depths of a\n   * storage system), and with it some powerful costs: use this feature with\n   * care.\n   *\n   * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to\n   * *future* causal descendants of the associated Span.\n   *\n   * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n   * value is copied into every local *and remote* child of the associated\n   * Span, and that can add up to a lot of network and cpu overhead.\n   *\n   * @param {string} key\n   * @param {string} value\n   */\n\n\n  Span.prototype.setBaggageItem = function (key, value) {\n    this._setBaggageItem(key, value);\n\n    return this;\n  };\n  /**\n   * Returns the value for a baggage item given its key.\n   *\n   * @param  {string} key\n   *         The key for the given trace attribute.\n   * @return {string}\n   *         String value for the given key, or undefined if the key does not\n   *         correspond to a set trace attribute.\n   */\n\n\n  Span.prototype.getBaggageItem = function (key) {\n    return this._getBaggageItem(key);\n  };\n  /**\n   * Adds a single tag to the span.  See `addTags()` for details.\n   *\n   * @param {string} key\n   * @param {any} value\n   */\n\n\n  Span.prototype.setTag = function (key, value) {\n    var _a; // NOTE: the call is normalized to a call to _addTags()\n\n\n    this._addTags((_a = {}, _a[key] = value, _a));\n\n    return this;\n  };\n  /**\n   * Adds the given key value pairs to the set of span tags.\n   *\n   * Multiple calls to addTags() results in the tags being the superset of\n   * all calls.\n   *\n   * The behavior of setting the same key multiple times on the same span\n   * is undefined.\n   *\n   * The supported type of the values is implementation-dependent.\n   * Implementations are expected to safely handle all types of values but\n   * may choose to ignore unrecognized / unhandle-able values (e.g. objects\n   * with cyclic references, function objects).\n   *\n   * @return {[type]} [description]\n   */\n\n\n  Span.prototype.addTags = function (keyValueMap) {\n    this._addTags(keyValueMap);\n\n    return this;\n  };\n  /**\n   * Add a log record to this Span, optionally at a user-provided timestamp.\n   *\n   * For example:\n   *\n   *     span.log({\n   *         size: rpc.size(),  // numeric value\n   *         URI: rpc.URI(),  // string value\n   *         payload: rpc.payload(),  // Object value\n   *         \"keys can be arbitrary strings\": rpc.foo(),\n   *     });\n   *\n   *     span.log({\n   *         \"error.description\": someError.description(),\n   *     }, someError.timestampMillis());\n   *\n   * @param {object} keyValuePairs\n   *        An object mapping string keys to arbitrary value types. All\n   *        Tracer implementations should support bool, string, and numeric\n   *        value types, and some may also support Object values.\n   * @param {number} timestamp\n   *        An optional parameter specifying the timestamp in milliseconds\n   *        since the Unix epoch. Fractional values are allowed so that\n   *        timestamps with sub-millisecond accuracy can be represented. If\n   *        not specified, the implementation is expected to use its notion\n   *        of the current time of the call.\n   */\n\n\n  Span.prototype.log = function (keyValuePairs, timestamp) {\n    this._log(keyValuePairs, timestamp);\n\n    return this;\n  };\n  /**\n   * DEPRECATED\n   */\n\n\n  Span.prototype.logEvent = function (eventName, payload) {\n    return this._log({\n      event: eventName,\n      payload: payload\n    });\n  };\n  /**\n   * Sets the end timestamp and finalizes Span state.\n   *\n   * With the exception of calls to Span.context() (which are always allowed),\n   * finish() must be the last call made to any span instance, and to do\n   * otherwise leads to undefined behavior.\n   *\n   * @param  {number} finishTime\n   *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n   *         values are supported for timestamps with sub-millisecond accuracy.\n   *         If not specified, the current time (as defined by the\n   *         implementation) will be used.\n   */\n\n\n  Span.prototype.finish = function (finishTime) {\n    this._finish(finishTime); // Do not return `this`. The Span generally should not be used after it\n    // is finished so chaining is not desired in this context.\n\n  }; // ---------------------------------------------------------------------- //\n  // Derived classes can choose to implement the below\n  // ---------------------------------------------------------------------- //\n  // By default returns a no-op SpanContext.\n\n\n  Span.prototype._context = function () {\n    return noop.spanContext;\n  }; // By default returns a no-op tracer.\n  //\n  // The base class could store the tracer that created it, but it does not\n  // in order to ensure the no-op span implementation has zero members,\n  // which allows V8 to aggressively optimize calls to such objects.\n\n\n  Span.prototype._tracer = function () {\n    return noop.tracer;\n  }; // By default does nothing\n\n\n  Span.prototype._setOperationName = function (name) {}; // By default does nothing\n\n\n  Span.prototype._setBaggageItem = function (key, value) {}; // By default does nothing\n\n\n  Span.prototype._getBaggageItem = function (key) {\n    return undefined;\n  }; // By default does nothing\n  //\n  // NOTE: both setTag() and addTags() map to this function. keyValuePairs\n  // will always be an associative array.\n\n\n  Span.prototype._addTags = function (keyValuePairs) {}; // By default does nothing\n\n\n  Span.prototype._log = function (keyValuePairs, timestamp) {}; // By default does nothing\n  //\n  // finishTime is expected to be either a number or undefined.\n\n\n  Span.prototype._finish = function (finishTime) {};\n\n  return Span;\n}();\n\nexports.Span = Span;\nexports.default = Span;","map":{"version":3,"sources":["../src/span.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar noop = require(\"./noop\");\n/**\n * Span represents a logical unit of work as part of a broader Trace. Examples\n * of span might include remote procedure calls or a in-process function calls\n * to sub-components. A Trace has a single, top-level \"root\" Span that in turn\n * may have zero or more child Spans, which in turn may have children.\n */\nvar Span = /** @class */ (function () {\n    function Span() {\n    }\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n    /**\n     * Returns the SpanContext object associated with this Span.\n     *\n     * @return {SpanContext}\n     */\n    Span.prototype.context = function () {\n        return this._context();\n    };\n    /**\n     * Returns the Tracer object used to create this Span.\n     *\n     * @return {Tracer}\n     */\n    Span.prototype.tracer = function () {\n        return this._tracer();\n    };\n    /**\n     * Sets the string name for the logical operation this span represents.\n     *\n     * @param {string} name\n     */\n    Span.prototype.setOperationName = function (name) {\n        this._setOperationName(name);\n        return this;\n    };\n    /**\n     * Sets a key:value pair on this Span that also propagates to future\n     * children of the associated Span.\n     *\n     * setBaggageItem() enables powerful functionality given a full-stack\n     * opentracing integration (e.g., arbitrary application data from a web\n     * client can make it, transparently, all the way into the depths of a\n     * storage system), and with it some powerful costs: use this feature with\n     * care.\n     *\n     * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to\n     * *future* causal descendants of the associated Span.\n     *\n     * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n     * value is copied into every local *and remote* child of the associated\n     * Span, and that can add up to a lot of network and cpu overhead.\n     *\n     * @param {string} key\n     * @param {string} value\n     */\n    Span.prototype.setBaggageItem = function (key, value) {\n        this._setBaggageItem(key, value);\n        return this;\n    };\n    /**\n     * Returns the value for a baggage item given its key.\n     *\n     * @param  {string} key\n     *         The key for the given trace attribute.\n     * @return {string}\n     *         String value for the given key, or undefined if the key does not\n     *         correspond to a set trace attribute.\n     */\n    Span.prototype.getBaggageItem = function (key) {\n        return this._getBaggageItem(key);\n    };\n    /**\n     * Adds a single tag to the span.  See `addTags()` for details.\n     *\n     * @param {string} key\n     * @param {any} value\n     */\n    Span.prototype.setTag = function (key, value) {\n        var _a;\n        // NOTE: the call is normalized to a call to _addTags()\n        this._addTags((_a = {}, _a[key] = value, _a));\n        return this;\n    };\n    /**\n     * Adds the given key value pairs to the set of span tags.\n     *\n     * Multiple calls to addTags() results in the tags being the superset of\n     * all calls.\n     *\n     * The behavior of setting the same key multiple times on the same span\n     * is undefined.\n     *\n     * The supported type of the values is implementation-dependent.\n     * Implementations are expected to safely handle all types of values but\n     * may choose to ignore unrecognized / unhandle-able values (e.g. objects\n     * with cyclic references, function objects).\n     *\n     * @return {[type]} [description]\n     */\n    Span.prototype.addTags = function (keyValueMap) {\n        this._addTags(keyValueMap);\n        return this;\n    };\n    /**\n     * Add a log record to this Span, optionally at a user-provided timestamp.\n     *\n     * For example:\n     *\n     *     span.log({\n     *         size: rpc.size(),  // numeric value\n     *         URI: rpc.URI(),  // string value\n     *         payload: rpc.payload(),  // Object value\n     *         \"keys can be arbitrary strings\": rpc.foo(),\n     *     });\n     *\n     *     span.log({\n     *         \"error.description\": someError.description(),\n     *     }, someError.timestampMillis());\n     *\n     * @param {object} keyValuePairs\n     *        An object mapping string keys to arbitrary value types. All\n     *        Tracer implementations should support bool, string, and numeric\n     *        value types, and some may also support Object values.\n     * @param {number} timestamp\n     *        An optional parameter specifying the timestamp in milliseconds\n     *        since the Unix epoch. Fractional values are allowed so that\n     *        timestamps with sub-millisecond accuracy can be represented. If\n     *        not specified, the implementation is expected to use its notion\n     *        of the current time of the call.\n     */\n    Span.prototype.log = function (keyValuePairs, timestamp) {\n        this._log(keyValuePairs, timestamp);\n        return this;\n    };\n    /**\n     * DEPRECATED\n     */\n    Span.prototype.logEvent = function (eventName, payload) {\n        return this._log({ event: eventName, payload: payload });\n    };\n    /**\n     * Sets the end timestamp and finalizes Span state.\n     *\n     * With the exception of calls to Span.context() (which are always allowed),\n     * finish() must be the last call made to any span instance, and to do\n     * otherwise leads to undefined behavior.\n     *\n     * @param  {number} finishTime\n     *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n     *         values are supported for timestamps with sub-millisecond accuracy.\n     *         If not specified, the current time (as defined by the\n     *         implementation) will be used.\n     */\n    Span.prototype.finish = function (finishTime) {\n        this._finish(finishTime);\n        // Do not return `this`. The Span generally should not be used after it\n        // is finished so chaining is not desired in this context.\n    };\n    // ---------------------------------------------------------------------- //\n    // Derived classes can choose to implement the below\n    // ---------------------------------------------------------------------- //\n    // By default returns a no-op SpanContext.\n    Span.prototype._context = function () {\n        return noop.spanContext;\n    };\n    // By default returns a no-op tracer.\n    //\n    // The base class could store the tracer that created it, but it does not\n    // in order to ensure the no-op span implementation has zero members,\n    // which allows V8 to aggressively optimize calls to such objects.\n    Span.prototype._tracer = function () {\n        return noop.tracer;\n    };\n    // By default does nothing\n    Span.prototype._setOperationName = function (name) {\n    };\n    // By default does nothing\n    Span.prototype._setBaggageItem = function (key, value) {\n    };\n    // By default does nothing\n    Span.prototype._getBaggageItem = function (key) {\n        return undefined;\n    };\n    // By default does nothing\n    //\n    // NOTE: both setTag() and addTags() map to this function. keyValuePairs\n    // will always be an associative array.\n    Span.prototype._addTags = function (keyValuePairs) {\n    };\n    // By default does nothing\n    Span.prototype._log = function (keyValuePairs, timestamp) {\n    };\n    // By default does nothing\n    //\n    // finishTime is expected to be either a number or undefined.\n    Span.prototype._finish = function (finishTime) {\n    };\n    return Span;\n}());\nexports.Span = Span;\nexports.default = Span;\n//# sourceMappingURL=span.js.map"]},"metadata":{},"sourceType":"script"}