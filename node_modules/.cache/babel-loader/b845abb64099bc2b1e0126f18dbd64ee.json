{"ast":null,"code":"(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define('error-stack-parser', ['stackframe'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('stackframe'));\n  } else {\n    root.ErrorStackParser = factory(root.StackFrame);\n  }\n})(this, function ErrorStackParser(StackFrame) {\n  'use strict';\n\n  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n  var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\n  function _map(array, fn, thisArg) {\n    if (typeof Array.prototype.map === 'function') {\n      return array.map(fn, thisArg);\n    } else {\n      var output = new Array(array.length);\n\n      for (var i = 0; i < array.length; i++) {\n        output[i] = fn.call(thisArg, array[i]);\n      }\n\n      return output;\n    }\n  }\n\n  function _filter(array, fn, thisArg) {\n    if (typeof Array.prototype.filter === 'function') {\n      return array.filter(fn, thisArg);\n    } else {\n      var output = [];\n\n      for (var i = 0; i < array.length; i++) {\n        if (fn.call(thisArg, array[i])) {\n          output.push(array[i]);\n        }\n      }\n\n      return output;\n    }\n  }\n\n  function _indexOf(array, target) {\n    if (typeof Array.prototype.indexOf === 'function') {\n      return array.indexOf(target);\n    } else {\n      for (var i = 0; i < array.length; i++) {\n        if (array[i] === target) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  }\n\n  return {\n    /**\n     * Given an Error object, extract the most information from it.\n     *\n     * @param {Error} error object\n     * @return {Array} of StackFrames\n     */\n    parse: function ErrorStackParser$$parse(error) {\n      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n        return this.parseOpera(error);\n      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n        return this.parseV8OrIE(error);\n      } else if (error.stack) {\n        return this.parseFFOrSafari(error);\n      } else {\n        throw new Error('Cannot parse given Error object');\n      }\n    },\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n      // Fail-fast but return locations like \"(native)\"\n      if (urlLike.indexOf(':') === -1) {\n        return [urlLike];\n      }\n\n      var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n      var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n      return [parts[1], parts[2] || undefined, parts[3] || undefined];\n    },\n    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n      var filtered = _filter(error.stack.split('\\n'), function (line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n      }, this);\n\n      return _map(filtered, function (line) {\n        if (line.indexOf('(eval ') > -1) {\n          // Throw away eval information until we implement stacktrace.js/stackframe#8\n          line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n        }\n\n        var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n        var locationParts = this.extractLocation(tokens.pop());\n        var functionName = tokens.join(' ') || undefined;\n        var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];\n        return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);\n      }, this);\n    },\n    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n      var filtered = _filter(error.stack.split('\\n'), function (line) {\n        return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n      }, this);\n\n      return _map(filtered, function (line) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        if (line.indexOf(' > eval') > -1) {\n          line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n        }\n\n        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n          // Safari eval frames only have function names and nothing else\n          return new StackFrame(line);\n        } else {\n          var tokens = line.split('@');\n          var locationParts = this.extractLocation(tokens.pop());\n          var functionName = tokens.join('@') || undefined;\n          return new StackFrame(functionName, undefined, locationParts[0], locationParts[1], locationParts[2], line);\n        }\n      }, this);\n    },\n    parseOpera: function ErrorStackParser$$parseOpera(e) {\n      if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n        return this.parseOpera9(e);\n      } else if (!e.stack) {\n        return this.parseOpera10(e);\n      } else {\n        return this.parseOpera11(e);\n      }\n    },\n    parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n      var lines = e.message.split('\\n');\n      var result = [];\n\n      for (var i = 2, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));\n        }\n      }\n\n      return result;\n    },\n    parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n      var lines = e.stacktrace.split('\\n');\n      var result = [];\n\n      for (var i = 0, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame(match[3] || undefined, undefined, match[2], match[1], undefined, lines[i]));\n        }\n      }\n\n      return result;\n    },\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n      var filtered = _filter(error.stack.split('\\n'), function (line) {\n        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n      }, this);\n\n      return _map(filtered, function (line) {\n        var tokens = line.split('@');\n        var locationParts = this.extractLocation(tokens.pop());\n        var functionCall = tokens.shift() || '';\n        var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^\\)]*\\)/g, '') || undefined;\n        var argsRaw;\n\n        if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n          argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n        }\n\n        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n        return new StackFrame(functionName, args, locationParts[0], locationParts[1], locationParts[2], line);\n      }, this);\n    }\n  };\n});","map":{"version":3,"sources":["/home/harish/windo/phoenix/node_modules/@elastic/apm-rum-core/node_modules/error-stack-parser/error-stack-parser.js"],"names":["root","factory","define","amd","exports","module","require","ErrorStackParser","StackFrame","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","_map","array","fn","thisArg","Array","prototype","map","output","length","i","call","_filter","filter","push","_indexOf","target","indexOf","parse","ErrorStackParser$$parse","error","stacktrace","parseOpera","stack","match","parseV8OrIE","parseFFOrSafari","Error","extractLocation","ErrorStackParser$$extractLocation","urlLike","regExp","parts","exec","replace","undefined","ErrorStackParser$$parseV8OrIE","filtered","split","line","tokens","slice","locationParts","pop","functionName","join","fileName","ErrorStackParser$$parseFFOrSafari","ErrorStackParser$$parseOpera","e","message","parseOpera9","parseOpera10","parseOpera11","ErrorStackParser$$parseOpera9","lineRE","lines","result","len","ErrorStackParser$$parseOpera10","ErrorStackParser$$parseOpera11","functionCall","shift","argsRaw","args"],"mappings":"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","sourcesContent":["(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('error-stack-parser', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.ErrorStackParser = factory(root.StackFrame);\n    }\n}(this, function ErrorStackParser(StackFrame) {\n    'use strict';\n\n    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\n    function _map(array, fn, thisArg) {\n        if (typeof Array.prototype.map === 'function') {\n            return array.map(fn, thisArg);\n        } else {\n            var output = new Array(array.length);\n            for (var i = 0; i < array.length; i++) {\n                output[i] = fn.call(thisArg, array[i]);\n            }\n            return output;\n        }\n    }\n\n    function _filter(array, fn, thisArg) {\n        if (typeof Array.prototype.filter === 'function') {\n            return array.filter(fn, thisArg);\n        } else {\n            var output = [];\n            for (var i = 0; i < array.length; i++) {\n                if (fn.call(thisArg, array[i])) {\n                    output.push(array[i]);\n                }\n            }\n            return output;\n        }\n    }\n\n    function _indexOf(array, target) {\n        if (typeof Array.prototype.indexOf === 'function') {\n            return array.indexOf(target);\n        } else {\n            for (var i = 0; i < array.length; i++) {\n                if (array[i] === target) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    }\n\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         *\n         * @param {Error} error object\n         * @return {Array} of StackFrames\n         */\n        parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error('Cannot parse given Error object');\n            }\n        },\n\n        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            // Fail-fast but return locations like \"(native)\"\n            if (urlLike.indexOf(':') === -1) {\n                return [urlLike];\n            }\n\n            var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n            var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n        },\n\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            var filtered = _filter(error.stack.split('\\n'), function(line) {\n                return !!line.match(CHROME_IE_STACK_REGEXP);\n            }, this);\n\n            return _map(filtered, function(line) {\n                if (line.indexOf('(eval ') > -1) {\n                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n                }\n                var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionName = tokens.join(' ') || undefined;\n                var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];\n\n                return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);\n            }, this);\n        },\n\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            var filtered = _filter(error.stack.split('\\n'), function(line) {\n                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n            }, this);\n\n            return _map(filtered, function(line) {\n                // Throw away eval information until we implement stacktrace.js/stackframe#8\n                if (line.indexOf(' > eval') > -1) {\n                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n                }\n\n                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n                    // Safari eval frames only have function names and nothing else\n                    return new StackFrame(line);\n                } else {\n                    var tokens = line.split('@');\n                    var locationParts = this.extractLocation(tokens.pop());\n                    var functionName = tokens.join('@') || undefined;\n                    return new StackFrame(functionName,\n                        undefined,\n                        locationParts[0],\n                        locationParts[1],\n                        locationParts[2],\n                        line);\n                }\n            }, this);\n        },\n\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n');\n            var result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));\n                }\n            }\n\n            return result;\n        },\n\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n');\n            var result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(\n                        new StackFrame(\n                            match[3] || undefined,\n                            undefined,\n                            match[2],\n                            match[1],\n                            undefined,\n                            lines[i]\n                        )\n                    );\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            var filtered = _filter(error.stack.split('\\n'), function(line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n            }, this);\n\n            return _map(filtered, function(line) {\n                var tokens = line.split('@');\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionCall = (tokens.shift() || '');\n                var functionName = functionCall\n                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n                }\n                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n                    undefined : argsRaw.split(',');\n                return new StackFrame(\n                    functionName,\n                    args,\n                    locationParts[0],\n                    locationParts[1],\n                    locationParts[2],\n                    line);\n            }, this);\n        }\n    };\n}));\n\n"]},"metadata":{},"sourceType":"script"}