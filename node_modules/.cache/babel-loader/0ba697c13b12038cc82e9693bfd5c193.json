{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Functions = require(\"./functions\");\n\nvar Noop = require(\"./noop\");\n\nvar span_1 = require(\"./span\");\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n *\n * Note to implementators: derived classes can choose to directly implement the\n * methods in the \"OpenTracing API methods\" section, or optionally the subset of\n * underscore-prefixed methods to pick up the argument checking and handling\n * automatically from the base class.\n */\n\n\nvar Tracer =\n/** @class */\nfunction () {\n  function Tracer() {} // ---------------------------------------------------------------------- //\n  // OpenTracing API methods\n  // ---------------------------------------------------------------------- //\n\n  /**\n   * Starts and returns a new Span representing a logical unit of work.\n   *\n   * For example:\n   *\n   *     // Start a new (parentless) root Span:\n   *     var parent = Tracer.startSpan('DoWork');\n   *\n   *     // Start a new (child) Span:\n   *     var child = Tracer.startSpan('load-from-db', {\n   *         childOf: parent.context(),\n   *     });\n   *\n   *     // Start a new async (FollowsFrom) Span:\n   *     var child = Tracer.startSpan('async-cache-write', {\n   *         references: [\n   *             opentracing.followsFrom(parent.context())\n   *         ],\n   *     });\n   *\n   * @param {string} name - the name of the operation (REQUIRED).\n   * @param {SpanOptions} [options] - options for the newly created span.\n   * @return {Span} - a new Span object.\n   */\n\n\n  Tracer.prototype.startSpan = function (name, options) {\n    if (options === void 0) {\n      options = {};\n    } // Convert options.childOf to fields.references as needed.\n\n\n    if (options.childOf) {\n      // Convert from a Span or a SpanContext into a Reference.\n      var childOf = Functions.childOf(options.childOf);\n\n      if (options.references) {\n        options.references.push(childOf);\n      } else {\n        options.references = [childOf];\n      }\n\n      delete options.childOf;\n    }\n\n    return this._startSpan(name, options);\n  };\n  /**\n   * Injects the given SpanContext instance for cross-process propagation\n   * within `carrier`. The expected type of `carrier` depends on the value of\n   * `format.\n   *\n   * OpenTracing defines a common set of `format` values (see\n   * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n   * an expected carrier type.\n   *\n   * Consider this pseudocode example:\n   *\n   *     var clientSpan = ...;\n   *     ...\n   *     // Inject clientSpan into a text carrier.\n   *     var headersCarrier = {};\n   *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n   *     // Incorporate the textCarrier into the outbound HTTP request header\n   *     // map.\n   *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n   *     // ... send the httpReq\n   *\n   * @param  {SpanContext} spanContext - the SpanContext to inject into the\n   *         carrier object. As a convenience, a Span instance may be passed\n   *         in instead (in which case its .context() is used for the\n   *         inject()).\n   * @param  {string} format - the format of the carrier.\n   * @param  {any} carrier - see the documentation for the chosen `format`\n   *         for a description of the carrier object.\n   */\n\n\n  Tracer.prototype.inject = function (spanContext, format, carrier) {\n    // Allow the user to pass a Span instead of a SpanContext\n    if (spanContext instanceof span_1.default) {\n      spanContext = spanContext.context();\n    }\n\n    return this._inject(spanContext, format, carrier);\n  };\n  /**\n   * Returns a SpanContext instance extracted from `carrier` in the given\n   * `format`.\n   *\n   * OpenTracing defines a common set of `format` values (see\n   * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n   * an expected carrier type.\n   *\n   * Consider this pseudocode example:\n   *\n   *     // Use the inbound HTTP request's headers as a text map carrier.\n   *     var headersCarrier = inboundHTTPReq.headers;\n   *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n   *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n   *\n   * @param  {string} format - the format of the carrier.\n   * @param  {any} carrier - the type of the carrier object is determined by\n   *         the format.\n   * @return {SpanContext}\n   *         The extracted SpanContext, or null if no such SpanContext could\n   *         be found in `carrier`\n   */\n\n\n  Tracer.prototype.extract = function (format, carrier) {\n    return this._extract(format, carrier);\n  }; // ---------------------------------------------------------------------- //\n  // Derived classes can choose to implement the below\n  // ---------------------------------------------------------------------- //\n  // NOTE: the input to this method is *always* an associative array. The\n  // public-facing startSpan() method normalizes the arguments so that\n  // all N implementations do not need to worry about variations in the call\n  // signature.\n  //\n  // The default behavior returns a no-op span.\n\n\n  Tracer.prototype._startSpan = function (name, fields) {\n    return Noop.span;\n  }; // The default behavior is a no-op.\n\n\n  Tracer.prototype._inject = function (spanContext, format, carrier) {}; // The default behavior is to return a no-op SpanContext.\n\n\n  Tracer.prototype._extract = function (format, carrier) {\n    return Noop.spanContext;\n  };\n\n  return Tracer;\n}();\n\nexports.Tracer = Tracer;\nexports.default = Tracer;","map":{"version":3,"sources":["../src/tracer.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,IAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAkCA;;;;;;;;;;AAUG;;;AACH,IAAA,MAAA;AAAA;AAAA,YAAA;AAAA,WAAA,MAAA,GAAA,CAmIC,CAnID,CAEI;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAuBG;;;AACH,EAAA,MAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,IAAV,EAAwB,OAAxB,EAAiD;AAAzB,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,EAAA;AAAyB,KAAA,CAE7C;;;AACA,QAAI,OAAO,CAAC,OAAZ,EAAqB;AACjB;AACA,UAAM,OAAO,GAAG,SAAS,CAAC,OAAV,CAAkB,OAAO,CAAC,OAA1B,CAAhB;;AACA,UAAI,OAAO,CAAC,UAAZ,EAAwB;AACpB,QAAA,OAAO,CAAC,UAAR,CAAmB,IAAnB,CAAwB,OAAxB;AACH,OAFD,MAEO;AACH,QAAA,OAAO,CAAC,UAAR,GAAqB,CAAC,OAAD,CAArB;AACH;;AACD,aAAO,OAAO,CAAC,OAAf;AACH;;AACD,WAAO,KAAK,UAAL,CAAgB,IAAhB,EAAsB,OAAtB,CAAP;AACH,GAdD;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BG;;;AACH,EAAA,MAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,WAAP,EAAwC,MAAxC,EAAwD,OAAxD,EAAoE;AAChE;AACA,QAAI,WAAW,YAAY,MAAA,CAAA,OAA3B,EAAiC;AAC7B,MAAA,WAAW,GAAG,WAAW,CAAC,OAAZ,EAAd;AACH;;AACD,WAAO,KAAK,OAAL,CAAa,WAAb,EAA0B,MAA1B,EAAkC,OAAlC,CAAP;AACH,GAND;AAQA;;;;;;;;;;;;;;;;;;;;;AAqBG;;;AACH,EAAA,MAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,MAAR,EAAwB,OAAxB,EAAoC;AAChC,WAAO,KAAK,QAAL,CAAc,MAAd,EAAsB,OAAtB,CAAP;AACH,GAFD,CAzGJ,CA6GI;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACU,EAAA,MAAA,CAAA,SAAA,CAAA,UAAA,GAAV,UAAqB,IAArB,EAAmC,MAAnC,EAAsD;AAClD,WAAO,IAAI,CAAC,IAAZ;AACH,GAFS,CAvHd,CA2HI;;;AACU,EAAA,MAAA,CAAA,SAAA,CAAA,OAAA,GAAV,UAAkB,WAAlB,EAA4C,MAA5C,EAA4D,OAA5D,EAAwE,CACvE,CADS,CA5Hd,CA+HI;;;AACU,EAAA,MAAA,CAAA,SAAA,CAAA,QAAA,GAAV,UAAmB,MAAnB,EAAmC,OAAnC,EAA+C;AAC3C,WAAO,IAAI,CAAC,WAAZ;AACH,GAFS;;AAGd,SAAA,MAAA;AAAC,CAnID,EAAA;;AAAa,OAAA,CAAA,MAAA,GAAA,MAAA;AAqIb,OAAA,CAAA,OAAA,GAAe,MAAf","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Functions = require(\"./functions\");\nvar Noop = require(\"./noop\");\nvar span_1 = require(\"./span\");\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n *\n * Note to implementators: derived classes can choose to directly implement the\n * methods in the \"OpenTracing API methods\" section, or optionally the subset of\n * underscore-prefixed methods to pick up the argument checking and handling\n * automatically from the base class.\n */\nvar Tracer = /** @class */ (function () {\n    function Tracer() {\n    }\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n    /**\n     * Starts and returns a new Span representing a logical unit of work.\n     *\n     * For example:\n     *\n     *     // Start a new (parentless) root Span:\n     *     var parent = Tracer.startSpan('DoWork');\n     *\n     *     // Start a new (child) Span:\n     *     var child = Tracer.startSpan('load-from-db', {\n     *         childOf: parent.context(),\n     *     });\n     *\n     *     // Start a new async (FollowsFrom) Span:\n     *     var child = Tracer.startSpan('async-cache-write', {\n     *         references: [\n     *             opentracing.followsFrom(parent.context())\n     *         ],\n     *     });\n     *\n     * @param {string} name - the name of the operation (REQUIRED).\n     * @param {SpanOptions} [options] - options for the newly created span.\n     * @return {Span} - a new Span object.\n     */\n    Tracer.prototype.startSpan = function (name, options) {\n        if (options === void 0) { options = {}; }\n        // Convert options.childOf to fields.references as needed.\n        if (options.childOf) {\n            // Convert from a Span or a SpanContext into a Reference.\n            var childOf = Functions.childOf(options.childOf);\n            if (options.references) {\n                options.references.push(childOf);\n            }\n            else {\n                options.references = [childOf];\n            }\n            delete (options.childOf);\n        }\n        return this._startSpan(name, options);\n    };\n    /**\n     * Injects the given SpanContext instance for cross-process propagation\n     * within `carrier`. The expected type of `carrier` depends on the value of\n     * `format.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     var clientSpan = ...;\n     *     ...\n     *     // Inject clientSpan into a text carrier.\n     *     var headersCarrier = {};\n     *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     // Incorporate the textCarrier into the outbound HTTP request header\n     *     // map.\n     *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n     *     // ... send the httpReq\n     *\n     * @param  {SpanContext} spanContext - the SpanContext to inject into the\n     *         carrier object. As a convenience, a Span instance may be passed\n     *         in instead (in which case its .context() is used for the\n     *         inject()).\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - see the documentation for the chosen `format`\n     *         for a description of the carrier object.\n     */\n    Tracer.prototype.inject = function (spanContext, format, carrier) {\n        // Allow the user to pass a Span instead of a SpanContext\n        if (spanContext instanceof span_1.default) {\n            spanContext = spanContext.context();\n        }\n        return this._inject(spanContext, format, carrier);\n    };\n    /**\n     * Returns a SpanContext instance extracted from `carrier` in the given\n     * `format`.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     // Use the inbound HTTP request's headers as a text map carrier.\n     *     var headersCarrier = inboundHTTPReq.headers;\n     *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n     *\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - the type of the carrier object is determined by\n     *         the format.\n     * @return {SpanContext}\n     *         The extracted SpanContext, or null if no such SpanContext could\n     *         be found in `carrier`\n     */\n    Tracer.prototype.extract = function (format, carrier) {\n        return this._extract(format, carrier);\n    };\n    // ---------------------------------------------------------------------- //\n    // Derived classes can choose to implement the below\n    // ---------------------------------------------------------------------- //\n    // NOTE: the input to this method is *always* an associative array. The\n    // public-facing startSpan() method normalizes the arguments so that\n    // all N implementations do not need to worry about variations in the call\n    // signature.\n    //\n    // The default behavior returns a no-op span.\n    Tracer.prototype._startSpan = function (name, fields) {\n        return Noop.span;\n    };\n    // The default behavior is a no-op.\n    Tracer.prototype._inject = function (spanContext, format, carrier) {\n    };\n    // The default behavior is to return a no-op SpanContext.\n    Tracer.prototype._extract = function (format, carrier) {\n        return Noop.spanContext;\n    };\n    return Tracer;\n}());\nexports.Tracer = Tracer;\nexports.default = Tracer;\n//# sourceMappingURL=tracer.js.map"]},"metadata":{},"sourceType":"script"}