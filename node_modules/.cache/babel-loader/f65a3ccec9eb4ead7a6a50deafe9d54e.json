{"ast":null,"code":"import { SCHEDULE, INVOKE, ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, EVENT_TARGET } from '../constants';\nimport { apmSymbol } from './patch-utils';\nvar eventTypes = ['click'];\nvar eventTypeSymbols = {};\n\nfor (var i = 0; i < eventTypes.length; i++) {\n  var et = eventTypes[i];\n  eventTypeSymbols[et] = apmSymbol(et);\n}\n\nfunction shouldInstrumentEvent(target, eventType, listenerFn) {\n  return target instanceof EventTarget && eventTypes.indexOf(eventType) >= 0 && typeof listenerFn === 'function';\n}\n\nexport function patchEventTarget(callback) {\n  if (!window.EventTarget) {\n    return;\n  }\n\n  var proto = window.EventTarget.prototype;\n  var nativeAddEventListener = proto[ADD_EVENT_LISTENER_STR];\n  var nativeRemoveEventListener = proto[REMOVE_EVENT_LISTENER_STR];\n\n  function findTaskIndex(existingTasks, eventType, listenerFn, capture) {\n    for (var _i = 0; _i < existingTasks.length; _i++) {\n      var task = existingTasks[_i];\n\n      if (task.eventType === eventType && task.listenerFn === listenerFn && task.capture === capture) {\n        return _i;\n      }\n    }\n\n    return -1;\n  }\n\n  function isCapture(options) {\n    var capture;\n\n    if (typeof options === 'boolean') {\n      capture = options;\n    } else {\n      capture = options ? !!options.capture : false;\n    }\n\n    return capture;\n  }\n\n  function createListenerWrapper(target, eventType, listenerFn, options) {\n    var eventSymbol = eventTypeSymbols[eventType];\n    if (!eventSymbol) return listenerFn;\n    var existingTasks = target[eventSymbol];\n    var capture = isCapture(options);\n\n    if (existingTasks) {\n      var taskIndex = findTaskIndex(existingTasks, eventType, listenerFn, capture);\n\n      if (taskIndex !== -1) {\n        var _task = existingTasks[taskIndex];\n        return _task.wrappingFn;\n      }\n    } else {\n      existingTasks = target[eventSymbol] = [];\n    }\n\n    var task = {\n      source: EVENT_TARGET,\n      eventType: eventType,\n      listenerFn: listenerFn,\n      capture: capture,\n      wrappingFn: wrappingFn\n    };\n    existingTasks.push(task);\n\n    function wrappingFn() {\n      var event = arguments[0];\n      task.target = event.target;\n      callback(SCHEDULE, task);\n      var result;\n\n      try {\n        result = listenerFn.apply(this, arguments);\n      } finally {\n        callback(INVOKE, task);\n      }\n\n      return result;\n    }\n\n    return wrappingFn;\n  }\n\n  function getWrappingFn(target, eventType, listenerFn, options) {\n    var eventSymbol = eventTypeSymbols[eventType];\n    var existingTasks = target[eventSymbol];\n\n    if (existingTasks) {\n      var capture = isCapture(options);\n      var taskIndex = findTaskIndex(existingTasks, eventType, listenerFn, capture);\n\n      if (taskIndex !== -1) {\n        var task = existingTasks[taskIndex];\n        existingTasks.splice(taskIndex, 1);\n\n        if (existingTasks.length === 0) {\n          target[eventSymbol] = undefined;\n        }\n\n        return task.wrappingFn;\n      }\n    }\n\n    return listenerFn;\n  }\n\n  proto[ADD_EVENT_LISTENER_STR] = function (eventType, listenerFn, optionsOrCapture) {\n    var target = this;\n\n    if (!shouldInstrumentEvent(target, eventType, listenerFn)) {\n      return nativeAddEventListener.apply(target, arguments);\n    }\n\n    var wrappingListenerFn = createListenerWrapper(target, eventType, listenerFn, optionsOrCapture);\n    var args = Array.prototype.slice.call(arguments);\n    args[1] = wrappingListenerFn;\n    return nativeAddEventListener.apply(target, args);\n  };\n\n  proto[REMOVE_EVENT_LISTENER_STR] = function (eventType, listenerFn, optionsOrCapture) {\n    var target = this;\n\n    if (!shouldInstrumentEvent(target, eventType, listenerFn)) {\n      return nativeRemoveEventListener.apply(target, arguments);\n    }\n\n    var wrappingFn = getWrappingFn(target, eventType, listenerFn, optionsOrCapture);\n    var args = Array.prototype.slice.call(arguments);\n    args[1] = wrappingFn;\n    return nativeRemoveEventListener.apply(target, args);\n  };\n}","map":{"version":3,"sources":["/home/harish/windo/phoenix/node_modules/@elastic/apm-rum-core/dist/es/common/patching/event-target-patch.js"],"names":["SCHEDULE","INVOKE","ADD_EVENT_LISTENER_STR","REMOVE_EVENT_LISTENER_STR","EVENT_TARGET","apmSymbol","eventTypes","eventTypeSymbols","i","length","et","shouldInstrumentEvent","target","eventType","listenerFn","EventTarget","indexOf","patchEventTarget","callback","window","proto","prototype","nativeAddEventListener","nativeRemoveEventListener","findTaskIndex","existingTasks","capture","_i","task","isCapture","options","createListenerWrapper","eventSymbol","taskIndex","_task","wrappingFn","source","push","event","arguments","result","apply","getWrappingFn","splice","undefined","optionsOrCapture","wrappingListenerFn","args","Array","slice","call"],"mappings":"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","sourcesContent":["import { SCHEDULE, INVOKE, ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, EVENT_TARGET } from '../constants';\nimport { apmSymbol } from './patch-utils';\nvar eventTypes = ['click'];\nvar eventTypeSymbols = {};\n\nfor (var i = 0; i < eventTypes.length; i++) {\n  var et = eventTypes[i];\n  eventTypeSymbols[et] = apmSymbol(et);\n}\n\nfunction shouldInstrumentEvent(target, eventType, listenerFn) {\n  return target instanceof EventTarget && eventTypes.indexOf(eventType) >= 0 && typeof listenerFn === 'function';\n}\n\nexport function patchEventTarget(callback) {\n  if (!window.EventTarget) {\n    return;\n  }\n\n  var proto = window.EventTarget.prototype;\n  var nativeAddEventListener = proto[ADD_EVENT_LISTENER_STR];\n  var nativeRemoveEventListener = proto[REMOVE_EVENT_LISTENER_STR];\n\n  function findTaskIndex(existingTasks, eventType, listenerFn, capture) {\n    for (var _i = 0; _i < existingTasks.length; _i++) {\n      var task = existingTasks[_i];\n\n      if (task.eventType === eventType && task.listenerFn === listenerFn && task.capture === capture) {\n        return _i;\n      }\n    }\n\n    return -1;\n  }\n\n  function isCapture(options) {\n    var capture;\n\n    if (typeof options === 'boolean') {\n      capture = options;\n    } else {\n      capture = options ? !!options.capture : false;\n    }\n\n    return capture;\n  }\n\n  function createListenerWrapper(target, eventType, listenerFn, options) {\n    var eventSymbol = eventTypeSymbols[eventType];\n    if (!eventSymbol) return listenerFn;\n    var existingTasks = target[eventSymbol];\n    var capture = isCapture(options);\n\n    if (existingTasks) {\n      var taskIndex = findTaskIndex(existingTasks, eventType, listenerFn, capture);\n\n      if (taskIndex !== -1) {\n        var _task = existingTasks[taskIndex];\n        return _task.wrappingFn;\n      }\n    } else {\n      existingTasks = target[eventSymbol] = [];\n    }\n\n    var task = {\n      source: EVENT_TARGET,\n      eventType: eventType,\n      listenerFn: listenerFn,\n      capture: capture,\n      wrappingFn: wrappingFn\n    };\n    existingTasks.push(task);\n\n    function wrappingFn() {\n      var event = arguments[0];\n      task.target = event.target;\n      callback(SCHEDULE, task);\n      var result;\n\n      try {\n        result = listenerFn.apply(this, arguments);\n      } finally {\n        callback(INVOKE, task);\n      }\n\n      return result;\n    }\n\n    return wrappingFn;\n  }\n\n  function getWrappingFn(target, eventType, listenerFn, options) {\n    var eventSymbol = eventTypeSymbols[eventType];\n    var existingTasks = target[eventSymbol];\n\n    if (existingTasks) {\n      var capture = isCapture(options);\n      var taskIndex = findTaskIndex(existingTasks, eventType, listenerFn, capture);\n\n      if (taskIndex !== -1) {\n        var task = existingTasks[taskIndex];\n        existingTasks.splice(taskIndex, 1);\n\n        if (existingTasks.length === 0) {\n          target[eventSymbol] = undefined;\n        }\n\n        return task.wrappingFn;\n      }\n    }\n\n    return listenerFn;\n  }\n\n  proto[ADD_EVENT_LISTENER_STR] = function (eventType, listenerFn, optionsOrCapture) {\n    var target = this;\n\n    if (!shouldInstrumentEvent(target, eventType, listenerFn)) {\n      return nativeAddEventListener.apply(target, arguments);\n    }\n\n    var wrappingListenerFn = createListenerWrapper(target, eventType, listenerFn, optionsOrCapture);\n    var args = Array.prototype.slice.call(arguments);\n    args[1] = wrappingListenerFn;\n    return nativeAddEventListener.apply(target, args);\n  };\n\n  proto[REMOVE_EVENT_LISTENER_STR] = function (eventType, listenerFn, optionsOrCapture) {\n    var target = this;\n\n    if (!shouldInstrumentEvent(target, eventType, listenerFn)) {\n      return nativeRemoveEventListener.apply(target, arguments);\n    }\n\n    var wrappingFn = getWrappingFn(target, eventType, listenerFn, optionsOrCapture);\n    var args = Array.prototype.slice.call(arguments);\n    args[1] = wrappingFn;\n    return nativeRemoveEventListener.apply(target, args);\n  };\n}"]},"metadata":{},"sourceType":"module"}